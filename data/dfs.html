<div class="theory-section">
    <h2>Поиск в глубину (DFS)</h2>
    <p>Поиск в глубину (Depth-First Search, DFS) — один из основных алгоритмов для обхода или поиска в структурах данных типа дерева или графа. Алгоритм начинает с корневой вершины (или произвольной вершины для графа) и исследует как можно дальше каждую ветвь перед возвратом.</p>
    
    <h3>Как работает DFS?</h3>
    <p>Алгоритм DFS работает по следующему принципу:</p>
    <ol>
        <li>Помечаем текущую вершину как посещённую</li>
        <li>Обрабатываем текущую вершину</li>
        <li>Рекурсивно посещаем все смежные непосещённые вершины</li>
    </ol>
    
    <h3>Области применения</h3>
    <ul>
        <li>Поиск связных компонентов графа</li>
        <li>Проверка графа на двудольность</li>
        <li>Топологическая сортировка</li>
        <li>Поиск мостов и точек сочленения</li>
        <li>Решение задач на лабиринты и пути</li>
    </ul>
    
    <h3>Временная сложность</h3>
    <p>Временная сложность алгоритма DFS составляет O(V + E), где V — количество вершин, E — количество рёбер в графе.</p>
    
    <div class="problems">
        <h3>Задачи для практики</h3>
        <ul>
            <li><a href="https://leetcode.com/problems/number-of-islands/" target="_blank">Number of Islands (LeetCode)</a></li>
            <li><a href="https://cses.fi/problemset/task/1192" target="_blank">Counting Rooms (CSES)</a></li>
            <li><a href="https://acmp.ru/index.asp?main=task&id_task=243" target="_blank">Поиск цикла в графе (ACMP)</a></li>
        </ul>
    </div>
</div>

<div class="visualization-section">
    <h2>Визуализация поиска в глубину (DFS)</h2>
    <p>Ниже представлена GIF-анимация, демонстрирующая процесс обхода графа с использованием алгоритма DFS:</p>
    <img src="https://upload.wikimedia.org/wikipedia/commons/7/7f/Depth-First-Search.gif" alt="Визуализация DFS">
    <p>На анимации видно, как алгоритм углубляется в граф, пока не достигнет конечной вершины, после чего возвращается к последней вершине с непосещёнными соседями.</p>
</div>

<div class="code-section">
    <h2>Реализация DFS на C++</h2>
    <p>Ниже представлена реализация алгоритма поиска в глубину на C++ с использованием рекурсии:</p>
    <pre><code>#include &lt;iostream>
#include &lt;vector>
using namespace std;

// Рекурсивная функция для реализации DFS
void DFS(int v, vector&lt;bool>& visited, vector&lt;vector&lt;int>>& graph) {
    // Помечаем текущую вершину как посещённую
    visited[v] = true;
    cout << v << " ";

    // Рекурсивно посещаем все смежные непосещённые вершины
    for (int u : graph[v]) {
        if (!visited[u]) {
            DFS(u, visited, graph);
        }
    }
}

// Основная функция для вызова DFS
void performDFS(vector&lt;vector&lt;int>>& graph, int start) {
    // Вектор для отслеживания посещённых вершин
    vector&lt;bool> visited(graph.size(), false);

    // Вызываем рекурсивную функцию DFS
    DFS(start, visited, graph);
}

int main() {
    // Пример графа в виде списка смежности
    vector&lt;vector&lt;int>> graph = {
        {1, 2},     // Вершина 0 соединена с вершинами 1 и 2
        {0, 3, 4},  // Вершина 1 соединена с вершинами 0, 3 и 4
        {0, 4},     // Вершина 2 соединена с вершинами 0 и 4
        {1, 5},     // Вершина 3 соединена с вершинами 1 и 5
        {1, 2},     // Вершина 4 соединена с вершинами 1 и 2
        {3}         // Вершина 5 соединена с вершиной 3
    };

    cout << "Результат обхода DFS, начиная с вершины 0:" << endl;
    performDFS(graph, 0);

    return 0;
}</code></pre>
    <h3>Пояснение к коду</h3>
    <p>Данный код реализует алгоритм поиска в глубину с использованием рекурсии. Граф представлен в виде списка смежности. Функция <code>DFS</code> рекурсивно посещает все вершины, доступные из текущей вершины, помечая их как посещённые.</p>
</div>
